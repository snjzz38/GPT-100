<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Humanize Any Text: GPT-100</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        :root {
            --primary: #1a4ab9;
            --bg: #f8fafc;
            --border: #d2d9e7;
            --text: #23272f;
        }
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 0;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
        }
        .container {
            max-width: 1000px;
            margin: 24px auto;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(26, 74, 185, 0.1);
            padding: 24px;
        }
        h1 {
            text-align: center;
            font-size: 1.6rem;
            margin-bottom: 8px;
        }
        .disclaimer {
            text-align: center;
            color: #64748b;
            font-size: 0.9rem;
            margin-bottom: 20px;
        }
        .controls {
            display: flex;
            gap: 16px;
            margin-bottom: 20px;
        }
        .control-group {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        label {
            margin-bottom: 8px;
            font-size: 0.9rem;
            color: var(--text);
        }
        textarea, input[type="number"], select {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 1rem;
            color: var(--text);
            background-color: #fff;
            resize: vertical;
            min-height: 120px;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        input[type="number"], select {
            min-height: auto;
            height: 48px;
        }
        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 20px;
            justify-content: center;
        }
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background-color 0.2s ease;
        }
        button.primary {
            background-color: var(--primary);
            color: #fff;
        }
        button.primary:hover {
            background-color: #153a99;
        }
        button.secondary {
            background-color: #e2e8f0;
            color: var(--primary);
        }
        button.secondary:hover {
            background-color: #cbd5e1;
        }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .progress-container {
            width: 100%;
            background-color: #e2e8f0;
            border-radius: 8px;
            margin-top: 20px;
            height: 20px;
            overflow: hidden;
            display: none;
        }
        .progress-bar {
            height: 100%;
            width: 0%;
            background-color: var(--primary);
            border-radius: 8px;
            transition: width 0.3s ease-in-out;
        }
        .status-message {
            text-align: center;
            margin-top: 10px;
            font-size: 0.95rem;
            color: #475569;
        }
        .footer {
            text-align: center;
            margin-top: 30px;
            font-size: 0.85rem;
            color: #64748b;
        }
        .output-metrics {
            display: flex;
            justify-content: flex-end;
            font-size: 0.9rem;
            color: #64748b;
            margin-top: 8px;
        }
        .output-metrics span {
            margin-left: 15px;
        }
        #json-output {
            background-color: #f0f4f8;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            white-space: pre-wrap;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.85rem;
            color: #334155;
            display: none; /* Hidden by default */
            max-height: 400px;
            overflow-y: auto;
        }
        .copy-button {
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Humanize Any Text: GPT-100</h1>
        <p class="disclaimer"><b style="font-size:24px;"></b>
              Still in beta development, expect lots of mistakes. 
             <br>May change facts, remove info, etc. ALWAYS CHECK THE RESULT.
             <br><br><br>
             </p>

        <div class="controls">
            <div class="control-group">
                <label for="input-text">Input AI-Generated Text:</label>
                <textarea id="input-text" placeholder="Paste your AI-generated text here..."></textarea>
                <div class="output-metrics">
                    <span id="input-count">0 words</span>
                </div>
            </div>
            <div class="control-group">
                <label for="output-text">Humanized Output:</label>
                <textarea id="output-text" readonly placeholder="Humanized text will appear here..."></textarea>
                <div class="output-metrics">
                    <span id="output-count">0 words</span>
                </div>
            </div>
        </div>

        <div class="button-group">
            <button id="process-btn" class="primary">Humanize Text</button>
            <button id="clear-btn" class="secondary">Clear All</button>
        </div>

        <div id="progress-container" class="progress-container">
            <div id="progress-bar" class="progress-bar"></div>
        </div>
        <div id="status-message" class="status-message"></div>

        <pre id="json-output"></pre>
        <button id="copy-json-btn" class="secondary copy-button" style="display: none;">Copy JSON</button>
    </div>

    <div class="footer">
        Powered by Groq API
    </div>

<script>
    const $ = id => document.getElementById(id);

    const inputTextEl = $('input-text');
    const outputTextEl = $('output-text');
    const processBtn = $('process-btn');
    const clearBtn = $('clear-btn');
    const inputCountEl = $('input-count');
    const outputCountEl = $('output-count');
    const progressContainer = $('progress-container');
    const progressBar = $('progress-bar');
    const statusEl = $('status-message');
    const jsonOutputEl = $('json-output');
    const copyJsonButton = $('copy-json-btn');

    const MAX_SECTION_LENGTH = 1200; // Max characters per section for Groq

    const updateWordCount = () => {
        const inputWords = inputTextEl.value.trim().match(/\S+/g) || [];
        inputCountEl.textContent = `${inputWords.length} words`;

        const outputWords = outputTextEl.value.trim().match(/\S+/g) || [];
        outputCountEl.textContent = `${outputWords.length} words`;
    };

    const init = () => {
        inputTextEl.addEventListener('input', updateWordCount);
        outputTextEl.addEventListener('input', updateWordCount); // For dynamic output count

        clearBtn.addEventListener('click', () => {
            inputTextEl.value = '';
            outputTextEl.value = '';
            jsonOutputEl.textContent = '';
            jsonOutputEl.style.display = 'none';
            if (copyJsonButton) {
                copyJsonButton.style.display = 'none';
            }
            statusEl.textContent = '';
            progressContainer.style.display = 'none';
            progressBar.style.width = '0%';
            processBtn.disabled = false;
            processBtn.textContent = 'Humanize Text';
            updateWordCount();
        });

        processBtn.addEventListener('click', processText);

        if (copyJsonButton) {
            copyJsonButton.addEventListener('click', () => {
                navigator.clipboard.writeText(jsonOutputEl.textContent).then(() => {
                    alert('JSON copied to clipboard!');
                }).catch(err => {
                    console.error('Failed to copy JSON: ', err);
                });
            });
        }

        updateWordCount(); // Initial count
    };

    // The API_KEY constant has been removed from here.
    // It will now be securely accessed in your Vercel serverless function (proxy.js).

    const apiCall = async (prompt, model, customTemperature = 1.0, retryCount = 0) => {
        // Models list is kept client-side to manage client-side retry logic for different models.
        const models = [
            'llama-3.1-8b-instant',
            'llama3-8b-8192',
            'gemma2-9b-it',
            'mistral-saba-24b',
            'llama3-70b-8192',
            'meta-llama/llama-4-maverick-17b-128e-instruct',
            'meta-llama/llama-4-scout-17b-16e-instruct',
            'meta-llama/llama-guard-4-12b',
            'llama-guard-3-8b',
            'meta-llama/llama-prompt-guard-2-22m',
            'meta-llama/llama-prompt-guard-2-86m'
        ];

        let modelToUse = model;
        if (!modelToUse) {
            // If no specific model is passed (i.e., for initial humanization),
            // iterate through the predefined models for retries.
            modelToUse = models[retryCount];
            if (retryCount >= models.length) {
                throw new Error('All available models failed to process the request after multiple retries.');
            }
        }

        console.log(`Attempting API call with model: ${modelToUse} (Temp: ${customTemperature}) - Retry: ${retryCount}`);

        try {
            // *** IMPORTANT: Fetch request now points to your backend proxy.js ***
            const response = await fetch('/api/proxy', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    prompt: prompt,
                    model: modelToUse,
                    temperature: customTemperature,
                    top_p: 0.98,
                    max_tokens: 2048
                })
            });

            if (!response.ok) {
                const errorBody = await response.json();
                console.error(`Local API call failed for model ${modelToUse}: HTTP Status ${response.status} - ${response.statusText}`, errorBody);

                // Handle retries and model fallback based on backend response or network issues
                if ((response.status >= 500 || response.status === 429 || (response.status === 400 && errorBody?.details?.message?.includes("context length exceeded"))) && retryCount < 2) {
                    console.warn(`Retrying local API call for model ${modelToUse} due to server/rate limit/token error...`);
                    await new Promise(resolve => setTimeout(resolve, 1500 * (retryCount + 1)));
                    return apiCall(prompt, model, customTemperature, retryCount + 1); // Retry with the same model (or null)
                } else if (response.status !== 200 && model === null && retryCount < models.length - 1) {
                     // Fallback to next model if initial humanization (model is null) failed
                     console.warn(`Falling back to next model for humanization...`);
                     return apiCall(prompt, null, customTemperature, retryCount + 1); // Pass null to try next model in sequence
                }
                throw new Error(errorBody.message || 'Failed to process request');
            }
            const data = await response.json();
            const content = data.choices?.[0]?.message?.content.trim() || null;
            return content;

        } catch (error) {
            console.error(`Error during local API call with model ${modelToUse}:`, error);
            // General network/client-side error retry
            if (retryCount < 2 && model === null) {
                console.warn(`Retrying local API call due to network/general error...`);
                await new Promise(resolve => setTimeout(resolve, 1500 * (retryCount + 1)));
                return apiCall(prompt, null, customTemperature, retryCount + 1);
            }
            throw error;
        }
    };

    const processText = async () => {
        const inputText = inputTextEl.value.trim();
        if (!inputText) {
            alert('Please enter text to humanize.');
            return;
        }

        processBtn.disabled = true;
        processBtn.textContent = 'Processing...';
        progressContainer.style.display = 'block';
        progressBar.style.width = '0%';
        statusEl.textContent = 'Splitting text into sections...';
        jsonOutputEl.textContent = '';
        jsonOutputEl.style.display = 'none';
        if (copyJsonButton) {
            copyJsonButton.style.display = 'none';
        }

        try {
            const rawSectionsArray = [];
            let currentSection = '';
            const paragraphs = inputText.split(/\n\n+/); // Split by one or more blank lines

            for (const para of paragraphs) {
                if ((currentSection + para).length > MAX_SECTION_LENGTH && currentSection !== '') {
                    rawSectionsArray.push(currentSection.trim());
                    currentSection = para + '\n\n';
                } else {
                    currentSection += para + '\n\n';
                }
            }
            if (currentSection !== '') {
                rawSectionsArray.push(currentSection.trim());
            }

            console.log('Original sections:', rawSectionsArray);
            statusEl.textContent = `Processing ${rawSectionsArray.length} sections...`;

            const humanizedOutputDict = {};
            const finalHumanizedSections = [];

            for (let i = 0; i < rawSectionsArray.length; i++) {
                const section = rawSectionsArray[i];
                statusEl.textContent = `Humanizing section ${i + 1}/${rawSectionsArray.length}...`;
                console.log(`Humanizing section ${i + 1}:`, section);

                let humanizedContent;

                // Attempt 1: Standard Humanization
                const humanizePrompt = `Humanize the following AI-generated text, making it sound natural, engaging, and unique. Avoid common AI phrases, repetitive structures, and overly formal language. Focus on flow, variety in sentence structure, and authentic expression. Ensure the core meaning is preserved. Return only the humanized text, nothing else:\n\n"${section}"`;
                humanizedContent = await apiCall(humanizePrompt, null, 1.0); // Pass null to let apiCall select model

                if (!humanizedContent || humanizedContent.toLowerCase().includes("as an ai model") || humanizedContent.length < section.length * 0.7) {
                    console.warn(`Section ${i + 1} - Initial humanization failed or was short. Retrying with higher temperature.`);
                    statusEl.textContent = `Retrying section ${i + 1} with higher temperature...`;
                    humanizedContent = await apiCall(humanizePrompt, null, 0.7); // Pass null to let apiCall select model
                }

                if (!humanizedContent) {
                    humanizedContent = `[Failed to humanize this section: "${section.substring(0, 100)}..."]`;
                }

                humanizedOutputDict[`section_${i + 1}_original`] = section;
                humanizedOutputDict[`section_${i + 1}_humanized_initial`] = humanizedContent;
                finalHumanizedSections.push(humanizedContent); // Add to final list

                // Optional: Review and Refine (can be a separate step or integrated)
                statusEl.textContent = `Reviewing humanized section ${i + 1}/${rawSectionsArray.length}...`;
                const reviewPrompt = `Review the following text for any signs of AI-generated patterns, stiffness, or unnatural phrasing. If detected, subtly rewrite only the problematic parts to make it sound more fluid, natural, and genuinely human. Focus on sentence variety, authentic tone, and engaging expression. Ensure the core meaning is preserved. If it already sounds human, return the text unchanged. Return only the revised text, nothing else:\n\n"${humanizedContent}"`;
                const reviewedContent = await apiCall(reviewPrompt, 'llama3-8b-8192', 0.1); // Use a specific, more stable model for review
                if (reviewedContent) {
                    humanizedOutputDict[`section_${i + 1}_humanized_reviewed`] = reviewedContent;
                    finalHumanizedSections[i] = reviewedContent; // Update with reviewed content
                } else {
                    humanizedOutputDict[`section_${i + 1}_humanized_reviewed`] = "Review failed, using initial humanized content.";
                }

                progressBar.style.width = `${Math.round(((i + 1) / rawSectionsArray.length) * 100)}%`;
            }

            // Final review of the entire combined text (optional, but good for overall cohesion)
            statusEl.textContent = 'Performing a final coherence and tone review...';
            const combinedHumanizedText = finalHumanizedSections.join('\n\n');
            const finalReviewPrompt = `Read the following entire text for overall coherence, natural flow, and consistency in human-like tone. Make any final subtle adjustments to improve its authenticity, readability, and engagement. Avoid introducing errors. Return only the revised text, nothing else:\n\n"${combinedHumanizedText}"`;
            const finalOutputText = await apiCall(finalReviewPrompt, 'llama3-8b-8192', 0.2); // Use a specific, more stable model for final review

            if (finalOutputText) {
                humanizedOutputDict.final_humanized_text = finalOutputText;
                outputTextEl.value = finalOutputText; // Corrected variable to outputTextEl
            } else {
                humanizedOutputDict.final_humanized_text = combinedHumanizedText;
                outputTextEl.value = combinedHumanizedText; // Fallback if final review fails, corrected variable
            }

            statusEl.textContent = 'All sections processed and reviewed. Assembling final output.';
            progressBar.style.width = '100%';

            outputTextEl.value = finalHumanizedSections.join('\n\n'); // Ensures the final joined text is in the output textarea

            const finalWords = outputTextEl.value.trim().match(/\S+/g) || [];
            $('output-count').textContent = `${finalWords.length} words`;

            jsonOutputEl.textContent = JSON.stringify(humanizedOutputDict, null, 2);
            jsonOutputEl.style.display = 'block';
            if (copyJsonButton) {
                copyJsonButton.style.display = 'inline-block';
            }
            statusEl.textContent = 'Humanization complete!';

        } catch (error) {
            outputTextEl.value = `Error: ${error.message}`;
            statusEl.textContent = `Failed: ${error.message.substring(0, 100)}...`;
            console.error('Processing error details:', error);
        } finally {
            setTimeout(() => {
                progressContainer.style.display = 'none';
                processBtn.disabled = false;
                processBtn.textContent = 'Humanize Text';
                if (!statusEl.textContent.startsWith('Failed:')) {
                    statusEl.textContent = '';
                }
            }, 2000);
        }
    };

    document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
