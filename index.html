// Enhanced text processing code with improved content preservation

// 1. Enhanced isNonsense function with word count validation
const isNonsense = (text, originalText) => {
    if (!text || text.trim().length < 10) return true;
    
    // Check if word count is within ±10% of original
    const origWords = originalText.trim().split(/\s+/).length;
    const newWords = text.trim().split(/\s+/).length;
    if (Math.abs(newWords - origWords) > origWords * 0.1) return true;
    
    // Additional nonsense checks
    const commonNonsensePatterns = [
        /^(here is|here's|the text|section|rewritten|paraphrased)/i,
        /^(as an|as requested|certainly|sure)/i,
        /^\d+\.\s/,  // Numbered lists
        /^[*-]\s/,   // Bullet points
    ];
    
    for (const pattern of commonNonsensePatterns) {
        if (pattern.test(text.trim())) return true;
    }
    
    // Check for repetitive content
    const words = text.toLowerCase().split(/\s+/);
    const uniqueWords = new Set(words);
    if (uniqueWords.size < words.length * 0.5) return true;
    
    return false;
};

// 2. Enhanced buildComprehensivePrompt with stronger content preservation
function buildComprehensivePrompt(sectionName, allSectionsDict, section, tone, isPersonal, pastParaphrases, sectionAnalysis) {
    const wc = section.trim().split(/\s+/).length;
    const min = Math.floor(wc * 0.9);
    const max = Math.ceil(wc * 1.1);
    
    // Build dictionary string for context
    const dictString = Object.entries(allSectionsDict)
        .map(([key, value]) => `"${key}": "${value.substring(0, 200)}${value.length > 200 ? '...' : ''}"`)
        .join(',\n');
    
    // Generate tone instruction
    const toneMap = {
        'professional': 'Maintain a formal, business-appropriate tone',
        'casual': 'Use a relaxed, conversational tone',
        'academic': 'Keep scholarly and precise language',
        'friendly': 'Use warm, approachable language'
    };
    const toneInstruction = toneMap[tone] || 'Maintain the original tone';
    
    // Personal context adjustments
    const specific = isPersonal ? 
        'PERSONAL CONTENT: This appears to be personal writing. Preserve the author\'s voice and personal details exactly.' :
        'PROFESSIONAL CONTENT: Maintain formal accuracy and professional terminology.';
    
    return `
**CONTEXT:**
The original text is split into sections and provided as a JavaScript-style dictionary. Each key is the section name, each value is the text for that section.
Section dictionary:
${dictString}

You are to paraphrase and restructure ONLY the section named "${sectionName}", using the full dictionary as context for coherence and natural flow.
CRITICAL: Preserve ALL key details, facts, and statistics. The output MUST contain the same information density as the input.

**TEXT TO REWRITE (ONE SINGLE SECTION):**
"${section}"

**MANDATORY RULES (STRICTLY ADHERE TO THESE):**

1. **WORD COUNT IS CRITICAL:** Output MUST be between ${min} and ${max} words (±10% of original ${wc} words).

2. **RESTRUCTURE MOST SENTENCES:** Rewrite at least 60% of sentences with fresh structure, but preserve ALL information:
   - Split long sentences into shorter ones
   - Combine short related sentences
   - Vary sentence beginnings
   - Change active/passive voice
   - Reorganize clauses
   BUT do not lose any facts, numbers, or key details.

3. **SIMPLIFY AND CLARIFY:** 
   - Use simpler synonyms when possible
   - Keep technical terms and proper nouns unchanged
   - Maintain formal but accessible language
   - Break down complex ideas into clearer statements
   BUT preserve the exact meaning and all specifics.

4. **CONVENTIONAL PUNCTUATION ONLY:** Use only periods (.), commas (,), exclamation marks (!), and question marks (?).

${specific}

5. **TONE:** ${toneInstruction}

6. **SINGLE PARAGRAPH OUTPUT:** The output for THIS specific section MUST be a single, continuous paragraph with NO newlines or extra spaces.

**Your response MUST be ONLY the rewritten text for this single section, nothing else.**`;
}

// 3. Enhanced final cleanup function
async function finalGrammarCleanup(text) {
    const prompt = `
As an expert editor, perform these exact tasks on the provided text:

1. REMOVE ALL AI ARTIFACTS:
   - Remove "here is the rewritten text", "section N:", etc.
   - Remove any meta-commentary or AI responses
   - Remove any section labels or numbers

2. FIX GRAMMAR AND CLARITY:
   - Correct all grammar, spelling, and punctuation
   - Use only periods (.), commas (,), exclamation marks (!), and question marks (?)
   - Fix any awkward phrasing while keeping the exact same meaning
   - Maintain all facts, numbers, and technical terms exactly as they appear

3. CLEAN STRUCTURE:
   - Remove participial phrases at sentence starts
   - Break up run-on sentences
   - Join related fragments
   - Keep paragraph breaks

DO NOT:
- Change any meanings
- Remove any information
- Add new content
- Change key terms or proper nouns
- Add any commentary

Input text:
"""
${text}
"""

Return ONLY the cleaned text with no added comments.`;

    try {
        let cleaned = await apiCall(prompt, 0, 0.1);
        cleaned = sanitizeAIOutput(cleaned);
        
        // Double-check word count
        const origWords = text.trim().split(/\s+/).length;
        const newWords = cleaned.trim().split(/\s+/).length;
        if (Math.abs(newWords - origWords) > origWords * 0.1) {
            return text; // Revert if too much changed
        }
        return cleaned;
    } catch (error) {
        console.error('Final cleanup failed:', error);
        return text;
    }
}

// 4. Enhanced sanitizeAIOutput function
function sanitizeAIOutput(text) {
    if (!text) return '';
    
    // Remove common AI prefixes and suffixes
    const patterns = [
        /^(here is|here's|the|section \d+:|rewritten text:|paraphrased version:)\s*/i,
        /\s*(that's the rewritten|hope this helps|let me know).*$/i,
        /^"(.*)"$/s, // Remove surrounding quotes
        /^\s*\d+\.\s*/, // Remove numbering
        /^\s*[-*]\s*/, // Remove bullet points
    ];
    
    let cleaned = text.trim();
    
    for (const pattern of patterns) {
        cleaned = cleaned.replace(pattern, '');
    }
    
    // Clean up extra whitespace
    cleaned = cleaned.replace(/\s+/g, ' ').trim();
    
    return cleaned;
}

// 5. Enhanced processSections function with additional validation
async function processSections(sections, tone = 'professional', isPersonal = false) {
    const results = {};
    const pastParaphrases = [];
    
    for (const [sectionName, sectionContent] of Object.entries(sections)) {
        if (!sectionContent || sectionContent.trim().length < 20) {
            results[sectionName] = sectionContent;
            continue;
        }
        
        const originalWordCount = sectionContent.trim().split(/\s+/).length;
        let attempts = 0;
        const maxAttempts = 3;
        let processedContent = null;
        
        while (attempts < maxAttempts && !processedContent) {
            try {
                // Build comprehensive prompt
                const prompt = buildComprehensivePrompt(
                    sectionName,
                    sections,
                    sectionContent,
                    tone,
                    isPersonal,
                    pastParaphrases,
                    null
                );
                
                // Get AI response
                let response = await apiCall(prompt, 0.7, 0.3);
                response = sanitizeAIOutput(response);
                
                // Validate response
                if (!isNonsense(response, sectionContent)) {
                    const newWordCount = response.trim().split(/\s+/).length;
                    const wordCountDiff = Math.abs(newWordCount - originalWordCount);
                    const allowedDiff = originalWordCount * 0.1;
                    
                    if (wordCountDiff <= allowedDiff) {
                        processedContent = response;
                        pastParaphrases.push(response.substring(0, 100));
                    }
                }
                
                attempts++;
            } catch (error) {
                console.error(`Error processing section ${sectionName}, attempt ${attempts + 1}:`, error);
                attempts++;
            }
        }
        
        // Final validation before adding to results
        if (processedContent) {
            const finalWordCount = processedContent.trim().split(/\s+/).length;
            if (Math.abs(finalWordCount - originalWordCount) > originalWordCount * 0.1) {
                processedContent = sectionContent; // Revert if too different
            }
        }
        
        results[sectionName] = processedContent || sectionContent;
    }
    
    return results;
}

// 6. Main processText function with enhanced validation
async function processText(inputText, tone = 'professional', isPersonal = false) {
    try {
        // Split text into sections (implementation depends on your sectioning logic)
        const sections = splitIntoSections(inputText);
        
        // Process each section
        const processedSections = await processSections(sections, tone, isPersonal);
        
        // Final assembly with cleanup
        const finalHumanizedSections = {};
        
        for (const [sectionName, content] of Object.entries(processedSections)) {
            let reviewedContent = content;
            
            // Apply final grammar cleanup
            if (content !== sections[sectionName]) {
                reviewedContent = await finalGrammarCleanup(content);
            }
            
            // Additional check before saving content
            if (reviewedContent && sections[sectionName]) {
                const origWords = sections[sectionName].trim().split(/\s+/).length;
                const newWords = reviewedContent.trim().split(/\s+/).length;
                if (Math.abs(newWords - origWords) > origWords * 0.1) {
                    reviewedContent = sections[sectionName]; // Revert if too different
                }
            }
            
            finalHumanizedSections[sectionName] = reviewedContent;
        }
        
        // Combine sections back into final text
        const finalText = Object.values(finalHumanizedSections).join('\n\n');
        
        return {
            success: true,
            originalText: inputText,
            processedText: finalText,
            sections: finalHumanizedSections,
            wordCountPreserved: validateWordCount(inputText, finalText)
        };
        
    } catch (error) {
        console.error('Text processing failed:', error);
        return {
            success: false,
            error: error.message,
            originalText: inputText
        };
    }
}

// Helper function to validate overall word count preservation
function validateWordCount(originalText, processedText) {
    const origWords = originalText.trim().split(/\s+/).length;
    const newWords = processedText.trim().split(/\s+/).length;
    const difference = Math.abs(newWords - origWords);
    const allowedDifference = origWords * 0.1;
    
    return {
        original: origWords,
        processed: newWords,
        difference: difference,
        withinLimits: difference <= allowedDifference,
        percentageChange: ((newWords - origWords) / origWords * 100).toFixed(2)
    };
}

// Placeholder for splitIntoSections function (implement based on your needs)
function splitIntoSections(text) {
    // This should contain your logic for splitting text into sections
    // For now, returning a simple paragraph-based split
    const paragraphs = text.split('\n\n').filter(p => p.trim().length > 0);
    const sections = {};
    
    paragraphs.forEach((paragraph, index) => {
        sections[`section_${index + 1}`] = paragraph.trim();
    });
    
    return sections;
}

// Placeholder for apiCall function (implement based on your API)
async function apiCall(prompt, temperature = 0.7, topP = 0.3) {
    // This should contain your API call logic
    // Return the AI response as a string
    throw new Error('apiCall function needs to be implemented with your specific API');
}

// Export functions for use
module.exports = {
    processText,
    processSections,
    buildComprehensivePrompt,
    finalGrammarCleanup,
    isNonsense,
    sanitizeAIOutput,
    validateWordCount
};
