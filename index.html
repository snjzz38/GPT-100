<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Enhanced AI Text Humanizer</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
:root{--primary:#1a4ab9;--bg:#f8fafc;--border:#d2d9e7;--text:#23272f}
*{box-sizing:border-box}
body{font-family:'Segoe UI',Arial;margin:0;background:var(--bg);color:var(--text);min-height:100vh}
.container{max-width:1000px;margin:24px auto;background:#fff;border-radius:12px;box-shadow:0 4px 12px rgba(26,74,185,0.1);padding:24px}
h1{text-align:center;font-size:1.6rem;margin-bottom:8px}
.disclaimer{text-align:center;color:#64748b;font-size:0.9rem;margin-bottom:20px}
.controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-bottom:16px}
select,button{padding:8px 16px;border-radius:8px;border:1px solid var(--border);font-size:0.95rem}
select{background:#f5f7fa}
button{background:var(--primary);color:#fff;border:none;font-weight:600;cursor:pointer}
button:hover{background:#143c8f}
button:disabled{background:#7abaff;cursor:not-allowed}
.toggle{display:flex;align-items:center;gap:8px}
.toggle input{width:40px;height:20px;appearance:none;background:#ccc;border-radius:20px;position:relative;cursor:pointer}
.toggle input:checked{background:var(--primary)}
.toggle input::before{content:'';width:16px;height:16px;background:#fff;border-radius:50%;position:absolute;top:2px;left:2px;transition:0.3s}
.toggle input:checked::before{left:22px}
.areas{display:flex;gap:16px;flex-direction:column}
@media(min-width:768px){.areas{flex-direction:row}}
.area{flex:1}
.area label{font-weight:600;color:var(--primary);display:block;margin-bottom:8px}
textarea{width:100%;min-height:200px;padding:10px;border:1px solid var(--border);border-radius:8px;background:#f5f7fa;font-family:'Fira Mono',monospace;font-size:0.9rem;resize:vertical;white-space:pre-wrap}
textarea:focus{border-color:var(--primary);outline:none}
.word-count{font-size:0.85rem;color:#64748b;text-align:right;margin-top:4px}
.progress{width:100%;height:4px;background:var(--border);border-radius:4px;margin:16px 0;display:none}
.progress-bar{height:100%;background:var(--primary);border-radius:4px;width:0;transition:width 0.3s}
.copy-btn{background:#64748b;padding:6px 12px;font-size:0.85rem;margin-left:8px}
.copy-btn:hover{background:#475569}
.status{font-size:0.85rem;color:#64748b;margin-top:8px;text-align:center}
</style>
</head>
<body>
<div class="container">
  <h1>Enhanced AI Text Humanizer</h1>
  <p class="disclaimer">Advanced version - intelligent word replacement with context awareness</p>
  
  <div class="controls">
    <select id="tone">
      <option value="professional">Professional</option>
      <option value="academic">Academic</option>
      <option value="casual">Casual</option>
    </select>
    <div class="toggle">
      <span>General</span>
      <input type="checkbox" id="perspective" checked>
      <span>Personal</span>
    </div>
    <button id="process">Humanize Text</button>
  </div>


  <div class="areas">
    <div class="area">
      <label>Input Text</label>
      <textarea id="input" placeholder="Paste your text here..."></textarea>
      <div class="word-count" id="input-count">0 words</div>
    </div>
    <div class="area">
      <label>Humanized Output <button class="copy-btn" id="copy">Copy</button></label>
      <textarea id="output" readonly></textarea>
      <div class="word-count" id="output-count">0 words</div>
    </div>
  </div>


  <div class="progress"><div class="progress-bar"></div></div>
  <div class="status" id="status"></div>
</div>


<script>
 let apiKey = "";
  async function getApiKey() {
    const res = await fetch('/api/key');
    const data = await res.json();
    apiKey = data.apiKey;
    console.log("Key loaded securely.");
  }
getApiKey();

const els = {
  input: document.getElementById('input'),
  output: document.getElementById('output'),
  tone: document.getElementById('tone'),
  perspective: document.getElementById('perspective'),
  process: document.getElementById('process'),
  copy: document.getElementById('copy'),
  progress: document.querySelector('.progress'),
  progressBar: document.querySelector('.progress-bar'),
  inputCount: document.getElementById('input-count'),
  outputCount: document.getElementById('output-count'),
  status: document.getElementById('status')
};


// Word complexity scoring algorithm
const commonWords = new Set([
  'the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 'i', 'it', 'for', 'not', 'on', 'with', 'he', 'as', 'you', 'do', 'at',
  'this', 'but', 'his', 'by', 'from', 'they', 'she', 'or', 'an', 'will', 'my', 'one', 'all', 'would', 'there', 'their', 'what',
  'so', 'up', 'out', 'if', 'about', 'who', 'get', 'which', 'go', 'me', 'when', 'make', 'can', 'like', 'time', 'no', 'just',
  'him', 'know', 'take', 'people', 'into', 'year', 'your', 'good', 'some', 'could', 'them', 'see', 'other', 'than', 'then',
  'now', 'look', 'only', 'come', 'its', 'over', 'think', 'also', 'back', 'after', 'use', 'two', 'how', 'our', 'work', 'first',
  'well', 'way', 'even', 'new', 'want', 'because', 'any', 'these', 'give', 'day', 'most', 'us', 'is', 'was', 'are', 'been',
  'has', 'had', 'were', 'said', 'each', 'which', 'their', 'said', 'did', 'get', 'may', 'find', 'water', 'long', 'down',
  'call', 'who', 'oil', 'sit', 'now', 'find', 'long', 'down', 'day', 'did', 'get', 'come', 'made', 'may', 'part'
]);


const calculateWordComplexity = (word, context = [], position = 0) => {
  const cleanWord = word.toLowerCase().replace(/[^\w]/g, '');
  let score = 0;
  
  // Length factor (0-3 points)
  if (cleanWord.length <= 4) score += 0;
  else if (cleanWord.length <= 7) score += 1;
  else if (cleanWord.length <= 10) score += 2;
  else score += 3;
  
  // Commonality factor (0-4 points)
  if (commonWords.has(cleanWord)) score += 0;
  else {
    // Estimate rarity based on patterns
    const hasLatinPrefix = /^(pre|post|anti|pro|sub|super|inter|trans|multi|semi|non|un|re|de|ex)/.test(cleanWord);
    const hasLatinSuffix = /(tion|sion|ment|ness|ity|ous|ious|eous|able|ible|ful|less|ward|wise|like|ship|hood|dom|ism|ist|ize|ise|ate|ify|ery|ary|ory|ing|ed|er|est|ly)$/.test(cleanWord);
    const hasMultipleSyllables = cleanWord.match(/[aeiou]/g)?.length > 2;
    
    if (hasLatinPrefix || hasLatinSuffix) score += 2;
    if (hasMultipleSyllables) score += 1;
    if (cleanWord.includes('ph') || cleanWord.includes('ch') || cleanWord.includes('th')) score += 1;
    if (!hasLatinPrefix && !hasLatinSuffix && cleanWord.length > 6) score += 2;
  }
  
  // Context factor (0-3 points)
  if (context.length > 0) {
    const prevWord = context[context.length - 1]?.toLowerCase();
    const academicContext = context.some(w => 
      ['furthermore', 'however', 'nevertheless', 'consequently', 'therefore', 'moreover'].includes(w.toLowerCase())
    );
    if (academicContext) score += 1;
    
    // Technical word clustering
    const technicalWords = context.filter(w => calculateWordComplexity(w) > 6).length;
    if (technicalWords > context.length * 0.3) score += 2;
  }
  
  return Math.min(score, 10);
};


// Enhanced word replacements with complexity scoring
const replacements = {
  'utilize': 'use', 'facilitate': 'help', 'demonstrate': 'show', 'implement': 'put in place',
  'approximately': 'about', 'numerous': 'many', 'significant': 'important', 'substantial': 'large',
  'adequate': 'enough', 'furthermore': 'also', 'nevertheless': 'but', 'consequently': 'so',
  'subsequently': 'then', 'accordingly': 'so', 'comprehensive': 'complete', 'extensive': 'wide',
  'optimize': 'improve', 'enhance': 'make better', 'establish': 'set up', 'determine': 'find out',
  'participate': 'take part', 'collaborate': 'work together', 'investigate': 'look into',
  'analyze': 'study', 'evaluate': 'check', 'assessment': 'review', 'methodology': 'method',
  'alternative': 'other option', 'component': 'part', 'element': 'part', 'aspect': 'part',
  'factor': 'thing', 'indicate': 'show', 'represent': 'stand for', 'constitute': 'make up',
  'acquire': 'get', 'obtain': 'get', 'purchase': 'buy', 'accomplish': 'do', 'achieve': 'reach',
  'commence': 'start', 'conclude': 'end', 'terminate': 'end', 'prioritize': 'focus on',
  'accumulated': 'built up', 'initiative': 'plan', 'objective': 'goal', 'fundamental': 'basic'
};


const fillers = ['specifically', 'particularly', 'essentially', 'basically', 'fundamentally'];


// Dash removal function
const removeDashes = text => {
  // Remove all em dashes
  text = text.replace(/â€”/g, '');
  
  // Remove en dashes that aren't connected on both sides
  // Keep hyphens that connect words (like "twenty-one", "self-made")
  // Remove standalone dashes with spaces around them
  text = text.replace(/\s+-\s+/g, ' '); // "word - word" becomes "word word"
  text = text.replace(/^\s*-\s*/gm, ''); // Remove dashes at start of lines
  text = text.replace(/\s*-\s*$/gm, ''); // Remove dashes at end of lines
  
  return text;
};


// Utility functions
const normalizeText = text => {
  return text
    .replace(/\r\n|\r/g, '\n')
    .replace(/\n{2,}/g, '\n\n')
    .trim();
};


const updateCount = (textarea, counter) => {
  const words = textarea.value.trim().split(/\s+/).filter(w => w).length;
  counter.textContent = `${words} words`;
};


const cleanResponse = text => {
  const patterns = [
    /^(here\s+(is|are)\s+.*?:?\s*)/i, /^(here'?s\s+.*?:?\s*)/i,
    /^(the\s+(requested|paraphrased).*?:?\s*)/i, /(i\s+hope\s+this\s+helps.*?)$/i,
    /^"(.*)"$/s, /^\s*[\"\'](.*)[\"\']?\s*$/s
  ];
  let cleaned = text.trim();
  patterns.forEach(pattern => {
    const match = cleaned.match(pattern);
    if (match && match[1]) {
      cleaned = pattern.source.startsWith('^') ? cleaned.replace(pattern, '').trim() : match[1].trim();
    }
  });
  return cleaned;
};


const extractProperNouns = text => {
  const nouns = new Set();
  const patterns = [
    /\b[A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*/g,
    /(?<!^|\.\s|\!\s|\?\s)\b[A-Z][a-z]{2,}\b/g,
    /\b[A-Z]{2,}\b/g
  ];
  patterns.forEach(pattern => {
    (text.match(pattern) || []).forEach(match => {
      if (!['The', 'This', 'That', 'We', 'I', 'You', 'He', 'She', 'It', 'They'].includes(match)) {
        nouns.add(match);
      }
    });
  });
  return Array.from(nouns);
};


// Dictionary API integration
const fetchSynonyms = async (word) => {
  try {
    const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word.toLowerCase()}`);
    if (!response.ok) return [];
    
    const data = await response.json();
    const synonyms = new Set();
    
    data.forEach(entry => {
      entry.meanings?.forEach(meaning => {
        meaning.definitions?.forEach(def => {
          def.synonyms?.forEach(syn => synonyms.add(syn));
        });
      });
    });
    
    return Array.from(synonyms).filter(syn => 
      calculateWordComplexity(syn) < calculateWordComplexity(word)
    );
  } catch (error) {
    console.error(`Error fetching synonyms for "${word}":`, error);
    return [];
  }
};


// Enhanced word replacement with API synonyms
const applySmartReplacements = async (text) => {
  els.status.textContent = 'Finding better words...';
  const words = text.split(/(\s+|[^\w\s]+)/);
  const context = [];
  
  for (let i = 0; i < words.length; i++) {
    const word = words[i];
    if (!/^\w+$/.test(word)) continue;
    
    const complexity = calculateWordComplexity(word, context);
    
    if (complexity >= 6) {
      // Try built-in replacements first
      const lowerWord = word.toLowerCase();
      if (replacements[lowerWord]) {
        words[i] = word[0] === word[0].toUpperCase() 
          ? replacements[lowerWord].charAt(0).toUpperCase() + replacements[lowerWord].slice(1)
          : replacements[lowerWord];
      } else {
        // Try API synonyms
        const synonyms = await fetchSynonyms(word);
        if (synonyms.length > 0) {
          const bestSynonym = synonyms[0];
          words[i] = word[0] === word[0].toUpperCase() 
            ? bestSynonym.charAt(0).toUpperCase() + bestSynonym.slice(1)
            : bestSynonym;
        }
      }
    }
    
    context.push(word);
    if (context.length > 10) context.shift();
  }
  
  let result = words.join('');
  
  // Remove filler words
  fillers.forEach(filler => {
    result = result.replace(new RegExp(`\\b${filler}\\b,?\\s*`, 'gi'), '');
  });
  
  return result.replace(/\s+/g, ' ').replace(/\s,/g, ',').trim();
};


const makeApiCall = async (prompt, wordCount, temp = null) => {
  try {
    const temperature = temp || parseFloat((Math.random() * 0.5 + 1.3).toFixed(2));
    const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
      method: 'POST',
      headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
      body: JSON.stringify({
        model: 'llama-3.1-8b-instant',
        messages: [{role: 'user', content: prompt}],
        max_tokens: Math.max(wordCount * 3, 100),
        temperature,
        top_p: 0.95,
        frequency_penalty: 0.3
      })
    });
    if (response.ok) {
      const data = await response.json();
      return data.choices[0].message.content.trim();
    }
  } catch (error) {
    console.error('API call error:', error);
  }
  return null;
};


const createSummaries = async text => {
  els.status.textContent = 'Analyzing content structure...';
  const sections = text.split(/\n{2,}/).filter(s => s.trim());
  const properNouns = extractProperNouns(text);
  
  const prompt = `Create concise 15-25 word summaries for each section. Include proper nouns: ${properNouns.join(', ')}. Return JSON only.


${sections.map((s, i) => `section${i + 1}:\n${s}`).join('\n\n')}


Format: {"section1": "summary...", "section2": "summary..."}`;


  try {
    const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
      method: 'POST',
      headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
      body: JSON.stringify({
        model: 'llama-3.1-8b-instant',
        messages: [{role: 'user', content: prompt}],
        max_tokens: 600,
        temperature: 0.6
      })
    });
    if (response.ok) {
      const data = await response.json();
      const summaries = JSON.parse(cleanResponse(data.choices[0].message.content));
      return Object.keys(summaries).length === sections.length ? summaries : {};
    }
  } catch (error) {
    console.error('Summary error:', error);
  }
  return {};
};


const removeParticipalPhrases = (text) => {
  // Remove past participial phrases at sentence start
  text = text.replace(/^([A-Z][a-z]+ed|[A-Z][a-z]+n)\s+[^,]+,\s*/gm, '');
  // Remove present participial phrases at sentence start  
  text = text.replace(/^([A-Z][a-z]+ing)\s+[^,]+,\s*/gm, '');
  // Remove mid-sentence participial phrases
  text = text.replace(/,\s+([a-z]+ed|[a-z]+ing)\s+[^,]+,/g, ',');
  return text;
};


const processSection = async (section, index, summaries, tone, isPersonal, allProperNouns) => {
  const wordCount = section.split(/\s+/).length;
  const minWords = Math.floor(wordCount * 0.9);
  const maxWords = Math.ceil(wordCount * 1.1);
  const sectionKey = `section${index + 1}`;
  const summary = summaries[sectionKey] || "";
  const sectionNouns = extractProperNouns(section);
  
  const isTitle = index === 0 && section.length < 120 && !section.includes('.');
  const sectionType = isTitle ? 'title' : 'paragraph';
  
  els.status.textContent = `Processing section ${index + 1}...`;
  
  // Step 1: Remove dashes first
  let processed = removeDashes(section);
  
  // Step 2: Apply smart word replacements
  processed = await applySmartReplacements(processed);
  
  // Step 3: Remove participial phrases
  processed = removeParticipalPhrases(processed);
  
  // Step 4: AI sentence restructuring with strict word count control
  const temp = parseFloat((Math.random() * 0.6 + 1.4).toFixed(2));
  
  const prompt = `PARAPHRASE and RESTRUCTURE this ${sectionType} in ${tone} tone${isPersonal ? ' using first person' : ''}. 


CRITICAL REQUIREMENTS:
- Keep EXACTLY ${minWords}-${maxWords} words (currently ${wordCount} words)
- PARAPHRASE - don't add new details or information
- RESTRUCTURE sentences while preserving exact meaning
- Preserve proper nouns: ${sectionNouns.join(', ')}
- Use simple, everyday words
- Active voice, natural flow
- NO new sections or paragraphs


Context: ${summary}


${processed}`;


  let result = await makeApiCall(prompt, wordCount, temp) || processed;
  result = cleanResponse(result);
  
  // Check word count and adjust if needed
  const resultWords = result.split(/\s+/).length;
  if (resultWords < minWords || resultWords > maxWords) {
    const adjustPrompt = `Adjust this to be exactly ${minWords}-${maxWords} words. Currently ${resultWords} words. Only paraphrase, don't add content:


${result}`;
    
    const adjusted = await makeApiCall(adjustPrompt, wordCount, 0.3);
    if (adjusted) result = cleanResponse(adjusted);
  }
  
  return result;
};


const grammarCheck = async text => {
  els.status.textContent = 'Final grammar check...';
  const sectionCount = text.split(/\n{2,}/).filter(s => s.trim()).length;
  
  const prompt = `Fix ONLY grammar, spelling, punctuation errors. Do NOT rephrase or change structure. Preserve ${sectionCount} paragraphs with double newlines:


${text}`;


  try {
    const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
      method: 'POST',
      headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
      body: JSON.stringify({
        model: 'llama-3.1-8b-instant',
        messages: [{role: 'user', content: prompt}],
        max_tokens: text.split(' ').length * 2,
        temperature: 0.2
      })
    });
    
    if (response.ok) {
      const data = await response.json();
      const corrected = cleanResponse(data.choices[0].message.content);
      const correctedSections = corrected.split(/\n{2,}/).filter(s => s.trim());
      return correctedSections.length === sectionCount ? corrected : text;
    }
  } catch (error) {
    console.error('Grammar check error:', error);
  }
  return text;
};


const processText = async (text, tone, isPersonal) => {
  // Apply dash removal first
  text = removeDashes(normalizeText(text));
  const sections = text.split(/\n{2,}/).filter(s => s.trim());
  const originalSectionCount = sections.length;
  
  const allProperNouns = extractProperNouns(text);
  const summaries = await createSummaries(text);
  
  const processed = [];
  for (let i = 0; i < sections.length; i++) {
    els.progressBar.style.width = `${10 + ((i + 1) / sections.length) * 80}%`;
    try {
      const result = await processSection(sections[i], i, summaries, tone, isPersonal, allProperNouns);
      processed.push(result);
    } catch (error) {
      console.error(`Error processing section ${i + 1}:`, error);
      processed.push(sections[i]);
    }
  }
  
  els.progressBar.style.width = '90%';
  
  // Ensure we maintain the same number of sections
  let result = processed.join('\n\n');
  const finalSections = result.split(/\n{2,}/).filter(s => s.trim());
  
  if (finalSections.length !== originalSectionCount) {
    console.warn(`Section count mismatch: ${originalSectionCount} -> ${finalSections.length}`);
  }
  
  els.progressBar.style.width = '95%';
  
  return result.replace(/\n{3,}/g, '\n\n').trim();
};


// Event listeners
updateCount(els.input, els.inputCount);
updateCount(els.output, els.outputCount);
els.input.addEventListener('input', () => updateCount(els.input, els.inputCount));
els.output.addEventListener('input', () => updateCount(els.output, els.outputCount));


els.copy.addEventListener('click', () => {
  els.output.select();
  document.execCommand('copy');
  els.copy.textContent = 'Copied!';
  setTimeout(() => els.copy.textContent = 'Copy', 1000);
});


els.process.addEventListener('click', async () => {
  const text = els.input.value.trim();
  if (!text) {
    alert('Please enter some text to humanize');
    return;
  }


  try {
    els.process.disabled = true;
    els.process.textContent = 'Processing...';
    els.progress.style.display = 'block';
    els.progressBar.style.width = '5%';
    els.status.textContent = 'Starting process...';


    const result = await processText(text, els.tone.value, els.perspective.checked);
    
    els.progressBar.style.width = '100%';
    els.output.value = result;
    updateCount(els.output, els.outputCount);
    els.status.textContent = 'Complete!';
  } catch (error) {
    console.error('Error:', error);
    els.output.value = 'An error occurred during processing. Please try again.';
    els.status.textContent = 'Error occurred';
  } finally {
    setTimeout(() => {
      els.progress.style.display = 'none';
      els.process.disabled = false;
      els.process.textContent = 'Humanize Text';
      els.status.textContent = '';
    }, 1500);
  }
});
</script>
</body>
</html>



