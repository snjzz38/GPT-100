<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Humanize Any Text: GPT-100</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        :root {
            --primary: #1a4ab9;
            --bg: #f8fafc;
            --border: #d2d9e7;
            --text: #23272f;
        }
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 0;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
        }
        .container {
            max-width: 1000px;
            margin: 24px auto;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(26, 74, 185, 0.1);
            padding: 24px;
        }
        h1 {
            text-align: center;
            font-size: 1.6rem;
            margin-bottom: 8px;
        }
        .disclaimer {
            text-align: center;
            color: #64748b;
            font-size: 0.9rem;
            margin-bottom: 20px;
        }
        .controls {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 16px;
        }
        select, button {
            padding: 8px 16px;
            border-radius: 8px;
            border: 1px solid var(--border);
            font-size: 0.95rem;
            background: #fff;
        }
        button {
            background: var(--primary);
            color: #fff;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover { background: #143c8f; }
        button:disabled {
            background: #a3b9e0;
            cursor: not-allowed;
        }
        .toggle {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .toggle input {
            width: 40px;
            height: 20px;
            appearance: none;
            background: #ccc;
            border-radius: 20px;
            position: relative;
            cursor: pointer;
            transition: transform 0.3s;
        }
        .toggle input::before {
            content: '';
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            position: absolute;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }
        .toggle input:checked {
            background: var(--primary);
        }
        .toggle input:checked::before { transform: translateX(20px); }
        .areas {
            display: flex;
            gap: 16px;
            flex-direction: column;
        }
        @media (min-width: 768px) {
            .areas { flex-direction: row; }
        }
        .area { flex: 1; }
        .area-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .area-header label {
            font-weight: 600;
            color: var(--primary);
        }
        .area-header button {
            background: #64748b;
            padding: 4px 10px;
            font-size: 0.85rem;
        }
        .area-header button:hover { background: #475569; }
        textarea {
            width: 100%;
            min-height: 250px;
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: #f8fafc;
            font-family: 'Fira Mono', monospace;
            font-size: 0.9rem;
            resize: vertical;
        }
        textarea:focus {
            border-color: var(--primary);
            outline: none;
            box-shadow: 0 0 0 2px rgba(26, 74, 185, 0.2);
        }
        .word-count {
            font-size: 0.85rem;
            color: #64748b;
            text-align: right;
            margin-top: 4px;
        }
        .progress {
            width: 100%;
            height: 4px;
            background: var(--border);
            border-radius: 4px;
            margin: 16px 0;
            overflow: hidden;
            display: none;
        }
        .progress-bar {
            height: 100%;
            background: var(--primary);
            border-radius: 4px;
            width: 0;
            transition: width 0.4s ease-out;
        }
        .status {
            font-size: 0.85rem;
            color: #64748b;
            margin-top: 8px;
            text-align: center;
            height: 1em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 style="font-size:60px;">GPT-100</h1>
        <p class="disclaimer"><b style="font-size:24px;">Humanize any AI-generated text.</b> <br><br>
             Still in beta development, expect lots of mistakes. 
             <br>May change/destroy facts, omit random information, make grammatical mistakes, etc. <br><br><b style="font-size:24px">ALWAYS CHECK!!!</b>
             <br><br>
             
        <div class="controls">
            <select id="tone">
                <option value="professional">Professional</option>
                <option value="academic">Academic</option>
                <option value="casual">Casual</option>
            </select>
            <div class="toggle">
                <span>General</span>
                <input type="checkbox" id="perspective" checked>
                <span>Personal</span>
            </div>
            <button id="process">Humanize Text</button>
        </div>
        <div class="areas">
            <div class="area">
                <div class="area-header">
                    <label for="input">Input Text</label>
                </div>
                <textarea id="input" placeholder="Paste your AI-generated text here, with paragraphs separated by newlines..."></textarea>
                <div class="word-count" id="input-count">0 words</div>
            </div>
            <div class="area">
                <div class="area-header" id="area-header-output">
                    <label for="output">Humanized Output</label>
                    <button id="copy">Copy</button>
                </div>
                <textarea id="output" readonly></textarea>
                <div class="word-count" id="output-count">0 words</div>
                <pre id="jsonOutput" style="white-space: pre-wrap; word-wrap: break-word; font-size: 0.8em; background-color: #f0f0f0; padding: 10px; border-radius: 5px; margin-top: 10px; display: none;"></pre>
            </div>
        </div>
        <div class="progress"><div class="progress-bar"></div></div>
        <div class="status" id="status"></div>
    </div>
<script>
    // Utility for getting elements by ID
    const $ = id => document.getElementById(id);

    // Constants for models (unchanged from your original)
    const MODELS_TO_TRY = [
        'llama-3.1-8b-instant',
        'llama3-8b-8192',
        'gemma2-9b-it',
        'mistral-saba-24b',
        'llama3-70b-8192',
        'meta-llama/llama-4-maverick-17b-128e-instruct',
        'meta-llama/llama-4-scout-17b-16e-instruct',
        'meta-llama/llama-guard-4-12b',
        'llama-guard-3-8b',
        'meta-llama/llama-prompt-guard-2-22m',
        'meta-llama/llama-prompt-guard-2-86m'
    ];

    // Comprehensive forbidden word list and AI prompt-focused list
    const FORBIDDEN_WORDS_COMPREHENSIVE = [
        'exacerbating', 'unequivocal', 'mitigate', 'transcends', 'stark', 'dire', 'exert', 'fortress', 'induce', 
        'ameliorate', 'socioeconomic', 'culminate', 'imperative', 'formidable', 'subsequently', 'hitherto', 
        'notwithstanding', 'thereby', 'thus', 'hence', 'whereas', 'moreover', 'furthermore', 'nevertheless', 
        'notable', 'significant', 'prevalent', 'consequently', 'therefore', 'delineate', 'underscore', 'paramount', 
        'pivotal', 'crucial', 'comprehensive', 'profound', 'vividly', 'crippled', 'waver', 'confronted', 
        'debilitating', 'susceptible', 'fluctuations', 'escalates', 'compromising', 'indestructible', 'equitable', 
        'resilient', 'resolve', 'portrayed', 'vividly', 'curb', 'dictates', 'proactive', 'bleak', 'intergovernmental', 
        'amplifies', 'consequences', 'rooted', 'excessive', 'emission', 'intensive', 'deforestation', 'shifting', 
        'frequent', 'torrential', 'downpours', 'crippled', 'terrain', 'biodiversity', 'strive', 'waning', 
        'outbreaks', 'debilitating', 'respiratory', 'socioeconomic', 'pose', 'considerable', 'susceptible', 
        'livelihood', 'delicacy', 'vastly', 'climatic', 'fluctuations', 'scarcity', 'alongside', 'triggers', 
        'migration', 'conflict', 'stability', 'financial', 'burden', 'inaction', 'inevitably', 'incur', 'escalating', 
        'eclipsing', 'restraints', 'proactive', 'encompass', 'shift', 'optimizing', 're-establishing', 'promoting', 
        'responsible', 'occupancy', 'crucially', 'cooperation', 'necessary', 'curb', 'pre-industrial', 'strengthening', 
        'infrastructure', 'resist', 'disasters', 'effective', 'awareness', 'systems', 'agricultural', 'practices', 
        'conserve', 'resources', 'significantly', 'harmony', 'balanced', 'distribution', 'disadvantaged', 'collective', 
        'pressing', 'reality', 'combat', 'challenge', 'approached', 'unified', 'international', 'presence', 'rooted', 
        'solid', 'evidence', 'innovative', 'solutions', 'universal', 'responsibility', 'insurmountable', 'obstacles', 
        'vast', 'opportunity', 'establish', 'sustainable', 'resilient', 'just', 'current and future generations', 
        'proactive', 'stance', 'define', 'sustainable', 'return', 'long', 'fragile', 'well-being',
        'necessitate', 'ecstatic', 'reedeem', 'utilize', 'alterations'
    ];
    const FORBIDDEN_WORDS_FOR_AI_PROMPT = [
        'unequivocal', 'mitigate', 'transcends', 'stark', 'dire', 'exert', 'fortress', 
        'induce', 'ameliorate', 'socioeconomic', 'culminate', 'imperative', 'formidable', 'subsequently', 
        'hitherto', 'notwithstanding', 'thereby', 'thus', 'hence', 'whereas', 'moreover', 'furthermore', 
        'nevertheless', 'consequently', 'therefore', 'delineate', 'underscore', 'paramount', 'pivotal', 
        'crucial', 'comprehensive', 'profound', 'vividly', 'crippled', 'waver', 'confronted', 'debilitating', 
        'susceptible', 'fluctuations', 'escalates', 'compromising', 'indestructible', 'equitable', 'resilient', 
        'resolve', 'portrayed', 'vividly', 'curb', 'dictates', 'proactive', 'bleak', 'intergovernmental', 
        'amplifies', 'consequences', 'rooted', 'excessive', 'emission', 'intensive', 'deforestation', 'shifting', 
        'frequent', 'torrential', 'downpours', 'crippled', 'terrain', 'biodiversity', 'strive', 'waning', 
        'outbreaks', 'debilitating', 'respiratory', 'socioeconomic', 'pose', 'considerable', 'susceptible', 
        'livelihood', 'delicacy', 'vastly', 'climatic', 'fluctuations', 'scarcity', 'alongside', 'triggers', 
        'migration', 'conflict', 'stability', 'financial', 'burden', 'inaction', 'inevitably', 'incur', 'escalating', 
        'eclipsing', 'restraints', 'proactive', 'encompass', 'shift', 'optimizing', 're-establishing', 'promoting', 
        'responsible', 'occupancy', 'crucially', 'cooperation', 'necessary', 'curb', 'pre-industrial', 'strengthening', 
        'infrastructure', 'resist', 'disasters', 'effective', 'awareness', 'systems', 'agricultural', 'practices', 
        'conserve', 'resources', 'significantly', 'harmony', 'balanced', 'distribution', 'disadvantaged', 'collective', 
        'pressing', 'reality', 'combat', 'challenge', 'approached', 'unified', 'international', 'presence', 'rooted', 
        'solid', 'evidence', 'innovative', 'solutions', 'universal', 'responsibility', 'insurmountable', 'obstacles', 
        'vast', 'opportunity', 'establish', 'sustainable', 'resilient', 'just', 'current and future generations', 
        'proactive', 'stance', 'define', 'sustainable', 'return', 'long', 'fragile', 'well-being',
        'necessitate', 'ecstatic', 'reedeem', 'utilize', 'alterations'
    ];

    // Helper: API call logic for model fallback
    const apiCall = async (prompt, modelIndex = 0, customTemperature = 1.9, retryCount = 0) => {
        if (modelIndex >= MODELS_TO_TRY.length) {
            throw new Error('All available models failed to process the request.');
        }
        const currentModel = MODELS_TO_TRY[modelIndex];
        try {
            const response = await fetch('/api/proxy', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    model: currentModel,
                    messages: [{ role: 'user', content: prompt }],
                    temperature: customTemperature,
                    top_p: 0.98,
                    max_tokens: 2048,
                }),
            });
            const data = await response.json();
            if (!response.ok) {
                const errorMsg = data.error || 'Unknown error';
                if (errorMsg.includes('maximum context length')) {
                    return apiCall(prompt, modelIndex + 1, customTemperature, 0);
                } else if (response.status === 429) {
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    return apiCall(prompt, modelIndex + 1, customTemperature, 0);
                } else if (response.status >= 500 || response.status === 404 || response.status === 403) {
                    if (retryCount < 2) {
                        await new Promise(resolve => setTimeout(resolve, 1500 * (retryCount + 1)));
                        return apiCall(prompt, modelIndex, customTemperature, retryCount + 1);
                    }
                    return apiCall(prompt, modelIndex + 1, customTemperature, 0);
                }
                throw new Error(errorMsg);
            }
            return data.choices?.[0]?.message?.content.trim() || null;
        } catch (error) {
            if (retryCount < 2) {
                await new Promise(resolve => setTimeout(resolve, 1500 * (retryCount + 1)));
                return apiCall(prompt, modelIndex, customTemperature, retryCount + 1);
            }
            return apiCall(prompt, modelIndex + 1, customTemperature, 0);
        }
    };

    // Helper: Detect likely nonsense or filler AI output
    const isNonsense = (text) => {
        if (!text || text.trim().length < 10) return true;
        const words = text.trim().split(/\s+/);
        const uniqueWords = new Set(words.map(w => w.toLowerCase()));
        if (words.length > 20 && uniqueWords.size / words.length < 0.3) return true;
        if (/[^a-zA-Z0-9\s.,!?'-]/.test(text)) {
            const unexpectedChars = text.match(/[^a-zA-Z0-9\s.,!?'-]/g);
            if (unexpectedChars && unexpectedChars.length / text.length > 0.05) return true;
        }
        if (/(as an ai language model|i am an ai|i cannot|i can help with that|here is the text you requested|let me know if you need any other assistance|i hope this helps|i've done my best|it is important to note|please note that|as previously mentioned)/i.test(text)) return true;
        if (words.length > 10 && !/[.!?]/.test(text)) return true;
        return false;
    };

    // Helper: Remove AI output boilerplate and clean up text
    const sanitizeAIOutput = (text) => {
        if (!text) return '';
        let cleanText = text;
        const prefixes = [
            "here's the rewritten text:", "here is the rewritten text:", "certainly, here's the revised paragraph:", 
            "of course, here is the updated version:", "here is your rewritten paragraph:", "rewritten text:", 
            "your rewritten text:", "here's the rewritten version:", "here's a rewritten version:", 
            "i have rewritten the text as follows:", "the rewritten text is:", "here you go:",
            "here's the humanized version:", "here's the humanized text:", "rewritten as requested:",
            "the text rewritten is:", "rewritten text:", "humanized output:", "output:", "here is the output:",
            "here's the output:", "i've rewritten the paragraph:", "here is the rewritten output for the section:",
            "here's the revised content:", "this is the humanized text:", "your humanized text:",
            "below is the rewritten text:", "i have transformed the text:", "the transformed text is:",
            "this is your updated section:", "here's your improved text:", "your text, humanized:",
            "the rewritten text is as follows:", "here's your new text:", "rewriting the text now:", 
            "i think this is what the user wants:", "the humanized text is:", "here's the humanized output:",
            "your requested output:", "here is the humanized version of the text:", "here is the updated text:",
            "i've processed the text:", "this is the revised text:", "the revised text is:", "your text revised:",
            "here's your text:", "here is your text:",
            "the urgency of addressing climate change: a pressing human concern", 
            "the urgency of addressing climate change. a pressing human concern",
            "the urgency of climate change is a worldwide concern.",
            "here's the corrected text:", "here's your corrected text:",
            "alright, here's the rewritten paragraph:", "let me know if you need any further adjustments.",
            "please note this is only one possible way to rewrite it.", "this is a possible humanized version:",
            "here's a humanized version of your text:",
            "the humanized output is:", "here's the humanized output you requested:",
            "this is the humanized text you asked for:", "i've rewritten the text for you:",
            "here is the revised text you requested:", "this is the rewritten version of your text:",
            "here is the humanized version of your provided text:",
            "your text has been humanized:", "i have humanized the text as follows:",
            "the humanized text you asked for:", "here is the humanized paragraph:"
        ];
        prefixes.sort((a, b) => b.length - a.length);
        for (const prefix of prefixes) {
            if (cleanText.toLowerCase().startsWith(prefix)) {
                cleanText = cleanText.substring(prefix.length).trim();
                break;
            }
        }
        cleanText = cleanText.replace(/^(as requested|here is your text|i've rephrased this for you|this is the rewritten text|this is your rewritten text|here is the rewritten text for the section|here's a version|this is the humanized version|rewritten:)\s*/i, '');
        cleanText = cleanText.replace(/^["'`]+|["'`]+$/g, '').trim();
        cleanText = cleanText.replace(/[\u2014\u2013]/g, ' ');
        cleanText = cleanText.replace(/,(\s*[.!?])/g, '$1');
        cleanText = cleanText.replace(/\s{2,}/g, ' ');
        cleanText = cleanText.replace(/\s*([.!?])\s*/g, '$1 ').trim();
        cleanText = cleanText.replace(/\s*,\s*/g, ', ');
        return cleanText;
    };

    // Helper: Replace forbidden words with a marker
    const enforceForbiddenWords = (text) => {
        let cleanText = text;
        FORBIDDEN_WORDS_COMPREHENSIVE.forEach(word => {
            const regex = new RegExp(`\\b${word}\\b`, 'gi');
            cleanText = cleanText.replace(regex, `[REPLACED WORD: ${word.toUpperCase()}]`);
        });
        return cleanText;
    };

    // Helper: Analyze a section for participial phrases, predictable starts, colons/semicolons
    const analyzeSectionForPatterns = (section) => {
        const issues = {
            hasParticipialPhrase: false,
            participialExamples: [],
            hasPredictableStart: false,
            predictableStartExamples: [],
            hasColonsOrSemicolons: false
        };
        const participialRegex = /(\b\w+(?:ing|ed|en)\b(?:(?:\s\w+)*?\s\w+)?)(?=\s|,|\.|$)/gi;
        let match;
        const sentences = section.match(/[^.!?]+[.!?]*/g) || [section];
        sentences.forEach(sentence => {
            while ((match = participialRegex.exec(sentence)) !== null) {
                const potentialPhrase = match[1].trim();
                if (potentialPhrase.length > 3 && 
                    !/^\b(?:is|are|was|were|has|have|had)\s/.test(sentence.substring(Math.max(0, match.index - 5), match.index)) &&
                    !/^\b(?:the|a|an)\s\w+(?:ing|ed|en)\b/.test(potentialPhrase.toLowerCase())) 
                {
                    issues.hasParticipialPhrase = true;
                    if (potentialPhrase && !issues.participialExamples.includes(potentialPhrase)) {
                        issues.participialExamples.push(`"${potentialPhrase.replace(/,$/, '')}"`);
                    }
                }
            }
        });
        const predictableStarts = [
            /^The world is/, /^Our planet/, /^Every year the earth/, /^Climate change is making things/, /^It is worth noting/, /^The key factor/, /^Rising global temperatures/, /^The dire economic effects/, /^It is important to note/, /^In conclusion/, /^Furthermore/, /^Moreover/, /^However/, /^Therefore/, /^Thus/, /^The fact that/, /^In order to/, /^Ultimately/, /^Despite the fact that/, /^While it may seem/, /^In essence/, /^What's more/, /^On the other hand/, /^Concurrently/, /^Subsequently/, /^In particular/, /^It is essential/, /^It is crucial/, /^It is clear that/, /^To summarize/, /^In summary/
        ];
        sentences.forEach(sentence => {
            const trimmedSentence = sentence.trim();
            for (const start of predictableStarts) {
                if (start.test(trimmedSentence)) {
                    issues.hasPredictableStart = true;
                    const example = trimmedSentence.split(' ').slice(0, 5).join(' ') + '...';
                    if (!issues.predictableStartExamples.includes(example)) {
                        issues.predictableStartExamples.push(`"${example}"`);
                    }
                    break;
                }
            }
        });
        if (/[;:]/.test(section)) {
            issues.hasColonsOrSemicolons = true;
        }
        return issues;
    };

    // Helper: Synonym and complexity section
    async function getDictionaryData(word) {
        try {
            const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(word)}`);
            if (!response.ok) throw new Error('No dictionary data');
            const data = await response.json();
            return data[0];
        } catch (e) {
            return null;
        }
    }

    function scoreWordComplexity(word, dictData) {
        if (!word) return 0;
        let complexity = 0;
        if (word.length > 7) complexity += 1;
        const syllables = word.split(/[^aeiouy]+/i).filter(Boolean).length;
        if (syllables >= 3) complexity += 1;
        if (dictData && dictData.meanings && dictData.meanings.length) {
            const parts = dictData.meanings.map(m => m.partOfSpeech);
            if (parts.includes('adjective') || parts.includes('adverb')) complexity += 1;
        }
        return complexity;
    }

    async function getSimplestSynonym(word, contextSection) {
        const dictData = await getDictionaryData(word);
        if (!dictData || !dictData.meanings) return null;
        let synonyms = [];
        for (const meaning of dictData.meanings) {
            if (Array.isArray(meaning.synonyms)) {
                synonyms = synonyms.concat(meaning.synonyms);
            }
        }
        synonyms = [...new Set(synonyms)];
        const origScore = scoreWordComplexity(word, dictData);
        let best = { word, score: origScore };
        for (const syn of synonyms) {
            if (!syn.match(/^[a-zA-Z]+$/)) continue;
            const synDict = await getDictionaryData(syn);
            const synScore = scoreWordComplexity(syn, synDict);
            if (synScore < best.score && contextSection.toLowerCase().includes(syn.toLowerCase())) {
                best = { word: syn, score: synScore };
            }
        }
        if (best.word !== word) return best.word;
        return null;
    }

    async function simplifySectionWords(textSection, contextSection) {
        const words = textSection.match(/\b\w+\b/g) || [];
        const checked = new Set();
        let newText = textSection;
        for (const w of words) {
            const lower = w.toLowerCase();
            if (checked.has(lower)) continue;
            checked.add(lower);
            if (w.length > 7 || w.match(/[A-Z]/) || w.match(/[aeiou]{3,}/i)) {
                const simple = await getSimplestSynonym(lower, contextSection);
                if (simple && simple !== lower) {
                    const reg = new RegExp("\\b" + w + "\\b", "gi");
                    newText = newText.replace(reg, simple);
                }
            }
        }
        return newText;
    }

    // Split input into dictionary of sections
    function splitInputToSectionDict(text) {
        const arr = text.split(/\n\s*\n+/).filter(s => s.trim());
        const dict = {};
        arr.forEach((content, idx) => {
            dict[`section${idx + 1}`] = content.trim();
        });
        return dict;
    }

    // Prompt generator using full input as a dictionary and section text
    function buildComprehensivePrompt(sectionName, allSectionsDict, section, tone, isPersonal, pastParaphrases, sectionAnalysis) {
        const toneInstruction = `Maintain a ${tone} tone${isPersonal ? ' using a first-person perspective (e.g., "I believe," "we must," "our responsibility").' : ' using a general, objective, and neutral perspective.'}`;
        let contextInstruction = '';
        if (pastParaphrases && pastParaphrases.length > 0) {
            const recentParaphrases = pastParaphrases.slice(-3); 
            contextInstruction = `
        **PREVIOUS CONTEXT AND STYLE (for flow only):**
        Previous humanized text sections: "${recentParaphrases.join('\n\n')}"
        Ensure the new section flows naturally from these. **DO NOT** reuse specific phrasing or sentence structures. Use *fresh synonyms* and *novel sentence constructions*.`;
        }
        let specificRefinementInstruction = '';
        if (sectionAnalysis.hasParticipialPhrase && sectionAnalysis.participialExamples.length > 0) {
            specificRefinementInstruction += `
            * **ABSOLUTELY RESTRUCTURE AND ELIMINATE ALL PARTICIPIAL PHRASES.** This is a critical requirement. Rewrite phrases like ${sectionAnalysis.participialExamples.join(', ')} as full, independent clauses.`;
        }
        if (sectionAnalysis.hasPredictableStart && sectionAnalysis.predictableStartExamples.length > 0) {
            specificRefinementInstruction += `
            * **VARY SENTENCE BEGINNINGS.** Avoid predictable starts like ${sectionAnalysis.predictableStartExamples.join(', ')}. Make every sentence start differently.`;
        }
        if (specificRefinementInstruction) {
            specificRefinementInstruction = `\n        **SECTION-SPECIFIC REFINEMENTS:**` + specificRefinementInstruction;
        }
        const originalWordCount = section.trim().split(/\s+/).length;
        const targetMinWords = Math.round(originalWordCount * 0.90); 
        const targetMaxWords = Math.round(originalWordCount * 1.10);
        const dictString = JSON.stringify(allSectionsDict, null, 2);
        return `
**CONTEXT:**
The original text is split into sections and provided as a JavaScript-style dictionary. Each key is the section name, each value is the text for that section.
Section dictionary:
${dictString}

You are to paraphrase and restructure ONLY the section named "${sectionName}", using the full dictionary as context for coherence and natural flow. 
Prioritize natural, human-like language and coherence, but ALWAYS preserve the exact factual meaning and context of the section in relation to the rest.

**TEXT TO REWRITE (ONE SINGLE SECTION):**
"${section}"

**MANDATORY RULES (STRICTLY ADHERE TO THESE):**

1.  **SIMPLIFY WORDS AND COMPLETELY RESTRUCTURE SENTENCES.** Use plain, everyday language. Avoid unnecessary complex vocabulary or jargon. When possible, use simpler synonyms for complex words, but ONLY if they fit the context and preserve meaning. If context would be lost, keep the original word.
2.  **STRICT WORD COUNT & CONTENT INTEGRITY.** Output for this section MUST be between **${targetMinWords} and ${targetMaxWords} words** (within +/- 10% of original ${originalWordCount} words).
3.  **PUNCTUATION AND TRANSITIONS.** **USE ONLY CONVENTIONAL PUNCTUATION: PERIODS (.), COMMAS (,), EXCLAMATION MARKS (!), AND QUESTION MARKS (?). ABSOLUTELY NO COLONS (:) OR SEMICOLONS (;).** 
${specificRefinementInstruction}
4.  **TONE.** ${toneInstruction}
${contextInstruction}
5.  **SINGLE PARAGRAPH OUTPUT.** The output for THIS specific section MUST be a single, continuous paragraph with NO newlines or extra spaces that create new paragraphs within it. **DO NOT introduce new content.**

**Your response MUST be ONLY the rewritten text for this single section, nothing else.**`;
    }

    // Individual section review prompt
    function buildIndividualSectionReviewPrompt(sectionText) {
        return `**GOLDEN RULE: DO NOT, under ANY circumstances, introduce ANY information, facts, or concepts not EXPLICITLY present in the "TEXT TO REVIEW" section below. Your output must be a pure revision.

You are an expert copy editor. Review the provided single paragraph ONLY for the following issues. **Your only output must be the corrected text, with no additional commentary or explanation.**

**STRICT CORRECTIONS ONLY for this single paragraph:**
* **COHERENCE AND GRAMMAR:** Ensure the text is perfectly coherent, grammatically correct, and makes complete sense. **DO NOT generate random or nonsensical text.** If the text is fundamentally nonsense, return the original.
* **CONVENTIONAL PUNCTUATION ONLY:** Replace **ALL colons (:) and semicolons (;)** with appropriate conventional punctuation (periods, commas, question marks, exclamation marks). Ensure all others are conventional.
* **ELIMINATE ALL PARTICIPIAL PHRASES:** Identify and rewrite *every single participial phrase* (e.g., "walking quickly," "being seen," "having done") into clear, full clauses or by splitting sentences.
* **REMOVE ALL AI COMMENTS/CONVERSATIONAL FILLER:** Ensure there are absolutely no introductory phrases, conversational remarks, questions to the user, or anything that resembles AI interaction.
* **NO MEANING CHANGE:** Do not change the original meaning, facts, or core information.
* **NO WORD CHOICE CHANGE (unless directly related to punctuation/grammar fix or specifically from the forbidden list if it slipped through):** Do not re-humanize or rephrase sentences beyond punctuation/grammar.
* **NO LENGTH CHANGE:** Do not significantly change the length of the text.
* **SINGLE PARAGRAPH OUTPUT:** The output MUST remain a single paragraph. DO NOT introduce newlines or merge with other (non-existent) paragraphs.

**TEXT TO REVIEW (SINGLE PARAGRAPH):**
"${sectionText}"

**FINAL OUTPUT (SINGLE PARAGRAPH):** ONLY the corrected text, with no preamble or commentary.`;
    }

    // Main processText function
    const processText = async () => {
        const text = $('input').value.trim();
        if (!text) {
            alert('Please enter text to humanize.');
            return;
        }
        const processBtn = $('process');
        const progressContainer = document.querySelector('.progress');
        const progressBar = document.querySelector('.progress-bar');
        const statusEl = $('status');
        const outputEl = $('output');
        const jsonOutputEl = $('jsonOutput');
        const copyJsonButton = $('copyJson');
        processBtn.disabled = true;
        processBtn.textContent = 'Processing...';
        progressContainer.style.display = 'block';
        progressBar.style.width = '0%';
        statusEl.textContent = 'Initializing...';
        outputEl.value = '';
        jsonOutputEl.textContent = '';
        jsonOutputEl.style.display = 'none';
        if (copyJsonButton) {
            copyJsonButton.style.display = 'none';
        }
        try {
            const tone = $('tone').value;
            const isPersonal = $('perspective').checked;
            const allSectionsDict = splitInputToSectionDict(text);
            const sectionNames = Object.keys(allSectionsDict);
            const originalInputDict = { ...allSectionsDict };
            const humanizedOutputDict = {};
            const finalHumanizedSections = [];
            for (let i = 0; i < sectionNames.length; i++) {
                const sectionKey = sectionNames[i];
                const originalSectionContent = allSectionsDict[sectionKey];
                statusEl.textContent = `Simplifying vocabulary for ${sectionKey}...`;
                const simplifiedSection = await simplifySectionWords(originalSectionContent, text);
                statusEl.textContent = `Humanizing ${sectionKey} of ${sectionNames.length}...`;
                const pastParaphrases = finalHumanizedSections;
                const sectionAnalysis = analyzeSectionForPatterns(simplifiedSection);
                const humanizePrompt = buildComprehensivePrompt(sectionKey, allSectionsDict, simplifiedSection, tone, isPersonal, pastParaphrases, sectionAnalysis);
                let humanizedContent = null;
                try {
                    humanizedContent = await apiCall(humanizePrompt, 0, 1.9);
                } catch (apiError) {
                    humanizedContent = null;
                }
                if (!humanizedContent || isNonsense(humanizedContent)) {
                    statusEl.textContent = `Retrying humanization for ${sectionKey}...`;
                    try {
                        humanizedContent = await apiCall(humanizePrompt, 0, 1.0);
                        if (isNonsense(humanizedContent)) {
                            humanizedContent = simplifiedSection;
                        }
                    } catch (retryError) {
                        humanizedContent = simplifiedSection;
                    }
                }
                humanizedContent = sanitizeAIOutput(humanizedContent);
                humanizedContent = enforceForbiddenWords(humanizedContent);
                statusEl.textContent = `Reviewing ${sectionKey} for punctuation and style...`;
                const reviewPrompt = buildIndividualSectionReviewPrompt(humanizedContent);
                let reviewedContent = null;
                try {
                    reviewedContent = await apiCall(reviewPrompt, 0, 0.1);
                } catch (reviewApiError) {
                    reviewedContent = humanizedContent;
                }
                if (!reviewedContent || isNonsense(reviewedContent)) {
                    reviewedContent = humanizedContent;
                } else {
                    reviewedContent = sanitizeAIOutput(reviewedContent);
                }
                humanizedOutputDict[sectionKey] = reviewedContent;
                finalHumanizedSections.push(reviewedContent);
                outputEl.value = finalHumanizedSections.join('\n\n');
                const words = outputEl.value.trim().match(/\S+/g) || [];
                $('output-count').textContent = `${words.length} words`;
                progressBar.style.width = `${Math.round(((i + 1) / sectionNames.length) * 100)}%`;
            }
            statusEl.textContent = 'All sections processed and reviewed. Assembling final output.';
            progressBar.style.width = '100%';
            outputEl.value = finalHumanizedSections.join('\n\n');
            const finalWords = outputEl.value.trim().match(/\S+/g) || [];
            $('output-count').textContent = `${finalWords.length} words`;
            jsonOutputEl.textContent = JSON.stringify(humanizedOutputDict, null, 2);
            jsonOutputEl.style.display = 'block';
            if (copyJsonButton) {
                copyJsonButton.style.display = 'inline-block';
            }
            statusEl.textContent = 'Humanization complete!';
        } catch (error) {
            outputEl.value = `Error: ${error.message}`;
            statusEl.textContent = `Failed: ${error.message.substring(0, 100)}...`;
        } finally {
            setTimeout(() => {
                progressContainer.style.display = 'none';
                processBtn.disabled = false;
                processBtn.textContent = 'Humanize Text';
                if (!statusEl.textContent.startsWith('Failed:')) {
                    statusEl.textContent = '';
                }
            }, 2000);
        }
    };

    // UI setup
    const init = () => {
        const processButton = $('process');
        if (!processButton) {
            console.error("Error: 'process' button not found in the DOM. Check its ID in HTML.");
            return;
        }
        ['input', 'output'].forEach(id => {
            const el = $(id);
            const counter = $(`${id}-count`);
            const updateCount = () => {
                const words = el.value.trim().match(/\S+/g) || [];
                counter.textContent = `${words.length} words`;
            };
            el.addEventListener('input', updateCount);
            updateCount();
        });
        const outputHeaderEl = $('area-header-output'); 
        if (outputHeaderEl) { 
            const copyJsonButton = document.createElement('button');
            copyJsonButton.id = 'copyJson';
            copyJsonButton.textContent = 'Copy JSON';
            copyJsonButton.style.marginLeft = '10px';
            copyJsonButton.style.display = 'none'; 
            outputHeaderEl.appendChild(copyJsonButton); 
            copyJsonButton.addEventListener('click', async () => {
                const jsonOutputEl = $('jsonOutput');
                if (!jsonOutputEl.textContent) return;
                try {
                    await navigator.clipboard.writeText(jsonOutputEl.textContent);
                    copyJsonButton.textContent = 'Copied!';
                    setTimeout(() => copyJsonButton.textContent = 'Copy JSON', 1500);
                } catch (err) {
                    alert('Failed to copy JSON.');
                }
            });
        }
        const copyTextButton = $('copy'); 
        if (copyTextButton) { 
            copyTextButton.addEventListener('click', async () => {
                const output = $('output');
                if (!output.value) return;
                try {
                    await navigator.clipboard.writeText(output.value);
                    copyTextButton.textContent = 'Copied!';
                    setTimeout(() => copyTextButton.textContent = 'Copy', 1500);
                } catch (err) {
                    alert('Failed to copy text.');
                }
            });
        }
        processButton.addEventListener('click', processText);
    };
    document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
